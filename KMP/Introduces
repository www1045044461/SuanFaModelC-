关于字符串模式匹配算法的原理
匹配模式字p[0--j-1],长度为ｊ　;匹配查找的字s[0--i-1];
假定p[k]匹配失败

１.最简单也最低效的方法--暴力方法
    如果p[ｋ]失败，就将j=0,i=i-j+2;
    但是当００００００００００００１与００１这样的匹配时会频繁的回溯．
    时间复杂度O(i+j)~O(i*j)//由于回溯的作用
２.改进使用ＫＭＰ算法．
    １．因为我们已经知道前面三个字符都是匹配的！（这很重要）。
     移动过去肯定也是不匹配的！有一个想法，i可以不动，我们只需要移动j即可.
    ２．整个KMP的重点就在于当某一个字符与主串不匹配时，
    我们应该知道j指针要移动到哪？
    3.当匹配失败时，j要移动的下一个位置k。存在着这样的性质：
    最前面的k个字符和j之前的最后k个字符是一样的。如果用数学公式来表示是这样的
P[0 ~ k-1] == P[j-k ~ j-1]
    4.因为在P的每一个位置都可能发生不匹配，也就是说我们要计算每一个位置j对应的k，
    所以用一个数组next来保存，next[j] = k，表示当T[i] != P[j]时，
    j指针的下一个位置。(生成ｎext[j]的算法)

            |-1 j=0;此时ｊ不可移动ｉ移动
            |
    next[j]=|Max{k|0<k<j-1 且满足p[0-k-1]=p[j-k-j-1]}，
              即已匹配部分的最大对称子串的对称点
            |
            |０ 其他情况