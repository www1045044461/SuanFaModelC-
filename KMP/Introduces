关于字符串模式匹配算法的原理
匹配模式字p[0--j-1],长度为ｊ　;匹配查找的字s[0--i-1];
假定p[k]匹配失败

１.最简单也最低效的方法--暴力方法
    如果p[ｋ]失败，就将j=0,i=i-j+2;
    但是当００００００００００００１与００１这样的匹配时会频繁的回溯．
    时间复杂度O(i+j)~O(i*j)//由于回溯的作用
２.改进使用ＫＭＰ算法．
    １．因为我们已经知道前面三个字符都是匹配的！（这很重要）。
     移动过去肯定也是不匹配的！有一个想法，i可以不动，我们只需要移动j即可.
    ２．整个KMP的重点就在于当某一个字符与主串不匹配时，
    我们应该知道j指针要移动到哪？
    3.当匹配失败时，j要移动的下一个位置k。存在着这样的性质：
    最前面的k个字符和j之前的最后k个字符是一样的。如果用数学公式来表示是这样的
P[0 ~ k-1] == P[j-k ~ j-1]
    4.因为在P的每一个位置都可能发生不匹配，也就是说我们要计算每一个位置j对应的k，
    所以用一个数组next来保存，next[j] = k，表示当T[i] != P[j]时，
    j指针的下一个位置。(生成ｎext[j]的算法)

            |-1 j=0;此时ｊ不可移动ｉ移动
            |
    next[j]=|Max{k|0<k<j-1 且满足p[0-k-1]=p[j-k-j-1]}，
              即已匹配部分的最大对称子串的对称点
            |
            |０ 其他情况
3.ＫＭＰ存在的缺陷(映射一致问题)
    当ｎｅｘｔ数组出现如下情况时会出现无意义的比较：P[j] == P[next[j]]
    即进过ｎｅｘｔ映射后的ｊ对应的位置与ｊ对应的位置的字符相等．
    当 a  a  a  a   b 
       -1 0  1  2   3
       -1 -1 -1 -1  3  
    在满足next[j+1]=next[j]+1时，即p[k]==p[j]时
    即当p[j]=p[next[j]]的时候,此时后面的next[j]=next[k];

总结：

    1.P[j]!=S[j]，KMP充值ｊ不重置i;使j重置到位置k;
    2.关于k的位置,在模式内有如下规律:p[0~k-1]=p[j-k~j-1]
    此时如果:p[k]==p[j]-->next[j+1]=next[j]+1;//即模式内有重复子串数+1(在下一个ｊ对应的映射)
    如果:p[k]!=p[j]-->next[j+1]=next[k]+1;//即:此字符暂时不构成重复子串，保持next[j]的值．
    3.如果在匹配的情况下，P[j] == P[next[j]]时，会有重复映射，这里使用next[j]=next[k];

